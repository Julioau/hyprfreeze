#!/usr/bin/env bash

function printHelp() {
	cat <<EOF
Usage: hyprfreeze (-a | -p <pid> | -n <name> | -r) [options]

Utility to suspend a game process (and other programs) in Hyprland.

Options:
  -h, --help            show help message

  -a, --active          toggle suspend by active window
  -p, --pid             toggle suspend by process id
  -n, --name            toggle suspend by process name/command
  -T, --title           toggle suspend by window title (regex)
  -r, --prop            toggle suspend by clicking on window (hyprprop must be installed)
  -w, --watch           continuously watch the window: pause when unfocused, resume when focused

  -s, --silent          don't send notification
  -t, --notif-timeout   notification timeout in milliseconds (default 5000)
  --dry-run             doesn't actually suspend/resume a process
  --debug               enable debug mode
  --no-xorg-workaround  skip the XWayland mouse capture workaround (other XWayland windows may become non-interactable)
EOF
}

function debugPrint() {
  if [ "$DEBUG" -eq 1 ]; then
    echo "[DEBUG] $1"
  fi
}

function releaseMouseCapture() {
  # Skip if workaround is disabled
  if [[ $NO_XORG_WORKAROUND == "1" ]]; then
    debugPrint "XWayland workaround disabled, skipping mouse capture release"
    return 0
  fi
  
  debugPrint "Attempting to release mouse capture for XWayland..."
  
  # Get the active window info
  local active_win
  active_win=$(hyprctl activewindow -j)
  
  # Check if the window we're about to pause is XWayland
  local is_xwayland
  is_xwayland=$(echo "$active_win" | jq -r '.xwayland')
  debugPrint "Is XWayland window: $is_xwayland"
  
  # If it's an XWayland window, use workspace switching to release mouse capture
  if [[ "$is_xwayland" == "true" ]]; then
    debugPrint "XWayland window detected - using workspace switching to release mouse capture..."
    
    # Get the current workspace
    local current_ws
    current_ws=$(hyprctl activeworkspace -j | jq -r '.id')
    debugPrint "Current workspace: $current_ws"
    
    # Find another workspace to switch to briefly
    local other_workspace
    other_workspace=$(hyprctl workspaces -j | jq -r '.[] | select(.id != '"$current_ws"') | .id' | head -1)
    
    if [ -n "$other_workspace" ]; then
      debugPrint "Switching to workspace $other_workspace and back to release mouse capture..."
      hyprctl dispatch workspace "$other_workspace"
      hyprctl dispatch workspace "$current_ws"
    else
      debugPrint "No other workspace found, cannot release mouse capture via workspace switching"
    fi
  fi
}

function getPids() {
  # Get pids of process tree
  PIDS=$(pstree -p "$PID" | grep -oP '\(\K[^\)]+')

  # Prevent suspending itself
  local pid_of_script=$$
  if echo "$PIDS" | grep -q "$pid_of_script"; then
    echo "You are trying to suspend the hyprfreeze process."
    exit 1
  fi
}

function suspendProcess() {
  if [[ $DRYRUN == "1" ]]; then return 0; fi
  getPids
  
  # Before suspending, release mouse capture for XWayland windows
  # In watch mode, we might not need this if focus is already lost, but safe to keep.
  releaseMouseCapture
  
  debugPrint "Suspending processes..."
  # shellcheck disable=SC2086
  kill -STOP $PIDS 2>/dev/null && echo "Suspended $(ps -p "$PID" -o comm= 2>/dev/null) (PID $PID)"
}

function resumeProcess() {
  if [[ $DRYRUN == "1" ]]; then return 0; fi
  getPids
  
  debugPrint "Resuming processes..."
  # shellcheck disable=SC2086
  kill -CONT $PIDS 2>/dev/null && echo "Resumed $(ps -p "$PID" -o comm= 2>/dev/null) (PID $PID)"
}

function toggleFreeze() {
  # Skip this function if --dry-run flag was provided
  # (Handled inside suspend/resume but keeping check for clarity if needed)
  if [[ $DRYRUN == "1" ]]; then return 0; fi

  getPids
  # Format PIDs for display (comma-separated)
  PIDS_DISPLAY=$(echo "$PIDS" | tr '\n' ',' | sed 's/,$//')
  debugPrint "PIDs: $PIDS_DISPLAY"

  # Suspend or resume processes
  if [[ "$(ps -o state= "$PID")" == T ]]; then
    resumeProcess || exit 1
  else
    suspendProcess || exit 1
  fi
}

function watchFreeze() {
  echo "Watching PID $PID for focus changes... Press Ctrl+C to stop."
  
  # Ensure process is resumed when script is terminated
  trap 'echo; echo "Stopping watch mode. Resuming process..."; resumeProcess; exit 0' SIGINT SIGTERM
  
  # Initial check
  local active_pid
  active_pid=$(hyprctl activewindow -j | jq '.pid')
  
  # Determine initial state
  if [[ "$active_pid" == "$PID" ]] || pstree -p "$PID" | grep -q "($active_pid)"; then
      if [[ "$(ps -o state= "$PID")" == T ]]; then resumeProcess; fi
  else
      if [[ "$(ps -o state= "$PID")" != T ]]; then suspendProcess; fi
  fi
  
  listen_socket | while read -r line; do
    if [[ "$line" == activewindow\>\>* ]]; then
      active_pid=$(hyprctl activewindow -j | jq '.pid')
      
      local is_target=0
      if [[ "$active_pid" == "$PID" ]]; then
          is_target=1
      elif pstree -p "$PID" | grep -q "($active_pid)"; then
          is_target=1
      fi
      
      if [[ "$is_target" == "1" ]]; then
        # Should be running
        if [[ "$(ps -o state= "$PID")" == T ]]; then
           resumeProcess
           if [ $SILENT -ne 1 ]; then sendNotification; fi
        fi
      else
        # Should be stopped
        if [[ "$(ps -o state= "$PID")" != T ]]; then
           suspendProcess
           if [ $SILENT -ne 1 ]; then sendNotification; fi
        fi
      fi
    fi
  done
}

function getPidByActive() {
  debugPrint "Getting PID by active window..."
  PID=$(hyprctl activewindow -j | jq '.pid')
  debugPrint "PID by active window: $PID"

  # Die if PID is not numeric (e.g. "null" if there is no active window)
  if ! [[ $PID == ?(-)+([[:digit:]]) ]]; then
    echo "Cannot freeze window with invalid PID $PID."
    exit 1
  fi
}

function getPidByPid() {
  debugPrint "Getting PID by PID: $1"
  # Check if process pid exists
  if ! ps -p "$1" &>/dev/null; then
    echo "Process ID $1 not found"
    exit 1
  fi

  PID=$1
}

function getPidByName() {
  debugPrint "Getting PID by name: $1"
  # Check if process name exists
  if ! pidof -x "$1" >/dev/null; then
    echo "Process name $1 not found"
    exit 1
  fi

  # Get last process if there are multiple
  PID=$(pidof "$1" | awk '{print $NF}')
  debugPrint "PID by name: $PID"
}

function getPidByTitle() {
  debugPrint "Getting PID by title regex: $1"
  # Use jq to find the first window whose title matches the regex
  # We select the 'pid' of the matching window
  PID=$(hyprctl clients -j | jq -r --arg title "$1" '.[] | select(.title | test($title; "i")) | .pid' | head -n 1)
  
  debugPrint "PID by title: $PID"

  if ! [[ $PID == ?(-)+([[:digit:]]) ]]; then
    echo "No window found with title matching '$1'."
    exit 1
  fi
}

function getPidByProp() {
  debugPrint "Getting PID by prop..."
  if ! command -v hyprprop >/dev/null; then
    echo "You need to install 'hyprprop' to use this feature. (https://github.com/vilari-mickopf/hyprprop)"
    exit 1
  fi

  PID=$(hyprprop | jq '.pid')
  debugPrint "PID by prop: $PID"
}

function sendNotification() {
  debugPrint "Sending notification..."
  local title
  title=$( [[ "$(ps -p "$PID" -o state=)" == T ]] &&
    echo "Suspended $(ps -p "$PID" -o comm= 2>/dev/null)" ||
    echo "Resumed $(ps -p "$PID" -o comm= 2>/dev/null)")

  local message="PID $PID"

  notify-send "${title}" "${message}" -t "$NOTIF_TIMEOUT" -a Hyprfreeze
}

function args() {
  # Track required flags
  local required_flag_count=0

  # Parse options
  local options="hap:n:T:rst:w"
  local long_options="help,active,pid:,name:,title:,prop,silent,notif-timeout:,dry-run,debug,no-xorg-workaround,watch"
  local parsed_args
  parsed_args=$(getopt -o "$options" --long "$long_options" -n "$(basename "$0")" -- "$@")

  eval set -- "$parsed_args"
  while true; do
    case $1 in
      -h | --help)
        printHelp
        exit 0
        ;;
      -a | --active)
        ((required_flag_count++))
        FLAG_ACTIVE=true
        ;;
      -p | --pid)
        ((required_flag_count++))
        shift
        FLAG_PID="$1"
        ;;
      -n | --name)
        ((required_flag_count++))
        shift
        NAME_FLAG="$1"
        ;;
      -T | --title)
        ((required_flag_count++))
        shift
        TITLE_FLAG="$1"
        ;;
      -r | --prop)
        ((required_flag_count++))
        FLAG_PROP=true
        ;;
      -w | --watch)
        WATCH_MODE=1
        ;;
      -s | --silent)
        SILENT=1
        ;;
      -t | --notif-timeout)
        shift
        NOTIF_TIMEOUT="$1"
        ;;
      --dry-run)
        DRYRUN=1
        ;;
      --debug)
        DEBUG=1
        ;;
      --no-xorg-workaround)
        NO_XORG_WORKAROUND=1
        ;;
      --)
        shift # Skip -- argument
        break
        ;;
      *)
        exit 1
        ;;
    esac
    shift
  done

  # Check if more than one required flag is provided, or if none was provided
  if [ $required_flag_count -ne 1 ]; then
    printHelp
    exit 1
  fi
}

function main() {
  debugPrint "Starting main function..."
  # Get pid by a required flag
  if [ "$FLAG_ACTIVE" = true ]; then
    getPidByActive
  elif [ -n "$FLAG_PID" ]; then
    getPidByPid "$FLAG_PID"
  elif [ -n "$NAME_FLAG" ]; then
    getPidByName "$NAME_FLAG"
  elif [ -n "$TITLE_FLAG" ]; then
    getPidByTitle "$TITLE_FLAG"
  elif [ "$FLAG_PROP" = true ]; then
    getPidByProp
  fi

  if [ "$WATCH_MODE" -eq 1 ]; then
    watchFreeze
  else
    # Suspend or resume process
    toggleFreeze

    # Send notification if not silent
    if [ $SILENT -ne 1 ]; then sendNotification; fi
  fi

  debugPrint "End of main function."
}

function listen_socket() {
  if ! command -v socat >/dev/null; then
    echo "Error: 'socat' is required for watch mode. Please install it."
    exit 1
  fi

  local socket_path="/tmp/hypr/$HYPRLAND_INSTANCE_SIGNATURE/.socket2.sock"
  if [[ -n "$XDG_RUNTIME_DIR" ]] && [[ -S "$XDG_RUNTIME_DIR/hypr/$HYPRLAND_INSTANCE_SIGNATURE/.socket2.sock" ]]; then
    socket_path="$XDG_RUNTIME_DIR/hypr/$HYPRLAND_INSTANCE_SIGNATURE/.socket2.sock"
  fi

  socat -U - "UNIX-CONNECT:$socket_path"
}

SILENT=0
NOTIF_TIMEOUT=5000
DRYRUN=0
DEBUG=0
NO_XORG_WORKAROUND=0
WATCH_MODE=0

args "$@"

main